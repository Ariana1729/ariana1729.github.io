import bisect
from Crypto.PublicKey import RSA
from gmpy2 import invert

n = 4079644068020126979264659039418892642884046949135257000505377213195924757271464117255416971335337315070324769584307693077859123919414332456581536099754567240839736831735241095007032602034386405545445415541569250236069019077436398773817919574611174377051543396598596980158227064751312624069307169767867524912061238986448096085160955432015970278827704690369573178269965186909762473530602471415648648691421951088807993006630475465229671524804527668247608752359018964987115703658265865187053126686268867739201841654187004947571120510525049889048547795065970147598600619640927455709119215119947110121742662420057493039489546554446459925041705961788139815628399844967556129319671809703695952053127726706324171563240792608404378953405001052170313816304620222561370364538303885888281108050095014201398240973657580355597232903735791436613395667521841113602568025080596932283774372271424759432591217460174854202440171576902854081511164235132415811904598632475991084928579845870092326810707843045109861633246639028733012850772688562598841341982145127524308887550878414190911342954895496415514893310787433772150210849112526501628522231648688423398130721938605652458598673914323116340663728112002370609057300976653903706789334105358171432288259
e = 0x10001
c = 0x00d9edd544f61a2c7efb7f7fdfd1fc6462719fdc1556ff3d99cf67b461936a6cdd27d3e9bcd331e90e129af11990c5d74951ad3378b6b4971e2a15c0b3d6d93fc03bf66604ba6eb30eee42040c8acdadf7321d6a3a8f1da7f8424e26f03fc1910579da50c8956a881f5448f29e265c17500cd2ec101c1f874ce6018ce264d3ca4c2eedadda249f8b76937a5b06e7d1f345a944a12e4d059f18692d412b90274b39aab452dd266bafa4cd6e5259a853b0b26a973a759b6ef6bd7b549496fbf211972b84bc75911fff6c9c74075493c9505c20756eaa2c195044c7022f283ad6c93b3e5a6c2723e61867dd51eaba11adb1b3be94f1839bb67e91de58c633bddb8abdb244907edbc74bca0e5d32054fd408065e13133f4586a17c11c302e7855ff7098d87f2826aa0a052954cee7561196d443c0926511702a29884c1c71b6f884ce544b1064f141f826579f38da7168fbfbfa24a0179da8eeac4aa29a1df8a47c47e1a66c0ddebbbcba084ba18d4ed11c2f1a45efd70ee03e666d060e0fae8a663501a9bcd7d83e38c0d3343b716289e5796177e461ff512263a68744eeb47efa15565ba6f112fb1ff21115a4ced4b6eebcec1548b255a0dd26bac9d8a8f4ffd66faaf25d75f94862a244e1965c73efb1c4cdac3a9f50ac01e87a0234d5b3b786415a1246774ecd64bc80b3f719b7ce5aeec6b8a7a0cad3890019443078689b085

def order(candidates):
    return sorted(candidates, key=lambda (p, q): bin(p).count('1') + bin(q).count('1'))

def recover(n, bits):
    candidates = {(0, 0)}
    for bit in range(0, bits):
        print(bit)
        remainder = n % (2 ** (bit + 1))
        new_candidates = set()
        for potential_p, potential_q in candidates:
            # extend by 0 bit and by 1 bit on the left, so candidate 101 -> 0101 and 1101
            extended_p = potential_p, (1 << bit) + potential_p
            extended_q = potential_q, (1 << bit) + potential_q
            for p in extended_p:
                for q in extended_q:
                    if (q, p) not in new_candidates: # p,q and q,p is the same for us
                        if (p * q) % (2 ** (bit + 1)) == remainder:
                            new_candidates.add((p, q))
        candidates = order(list(new_candidates))[:4096 * 8]
    return candidates

'''
candidates = recover(n, 2048)
for (p, q) in candidates:
    if n % p == 0:
        q = n / p
        break
    if n % q == 0:
        p = n / q
        break
'''

p = 2019812879456937956294679799568239399370274333791818393406604763427740318489850215533814867245507485805751969586029945421355552984955653377516005593131696478884104708088222858493257757684642890043858463258278143561976382354721689807799661597037169241242009093213887551815682060845601359347552623836736372968559512946834014151738581188707835790666964530035732879307916580371473836504901656666234869002918604144825901006767352010270945184739746045986030185276273159786624836120901286031547516796974508687777642593483036911381623501161215748619421703644967089992005032927483624594539980281742587790903614409497171197953
q = n / p
print('p', p)
print('q', q)
d = invert(e,(p-1)*(q-1))
m = pow(c,d,n)
m = hex(m)[2:].strip("L")
if len(m)%2==1:
    m = "0"+m
print m.decode("hex")
